<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reframed</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            /* ğŸ’¡ 1. ì „ì—­ ì»¤ì„œ ìˆ¨ê¸°ê¸° */
            cursor: none;
        }
        canvas { 
            display: block; 
        }

        /* ğŸ’¡ 2. ì»¤ìŠ¤í…€ ì»¤ì„œ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        .custom-cursor {
            width: 20px; 
            height: 20px;
            border-radius: 50%;
            background-color: #ffffff; /* ë°˜ì „ íš¨ê³¼ë¥¼ ìœ„í•´ í°ìƒ‰ ì„¤ì • */
            position: fixed; /* ë·°í¬íŠ¸ ê¸°ì¤€ìœ¼ë¡œ ìœ„ì¹˜ ê³ ì • */
            pointer-events: none; /* ìº”ë²„ìŠ¤ í´ë¦­ ë°©í•´ ë°©ì§€ */
            z-index: 9999; /* ìµœìƒë‹¨ì— ìœ„ì¹˜ */
            transform: translate(-50%, -50%); /* ì¤‘ì‹¬ì„ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë§ì¶¤ */
            transition: transform 0.1s ease-out; /* ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ */
            
            /* ğŸ’¡ 3. 'ë°˜ì „ íš¨ê³¼' í•µì‹¬ ì†ì„± */
            mix-blend-mode: difference; 
            opacity: 1; 
            will-change: transform; 
        }
    </style>
</head>
<body>
    <div class="custom-cursor" id="custom-cursor"></div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // ğŸ’¡ ì»¤ìŠ¤í…€ ì»¤ì„œ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
        const customCursor = document.getElementById('custom-cursor');

        // --- 1. ê¸°ë³¸ ì„¤ì • ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); 

        const yawObject = new THREE.Object3D();
        yawObject.position.set(0, 0, 0);
        yawObject.add(camera); 
        scene.add(yawObject);  
        
        camera.position.set(0, 0, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio); 
        document.body.appendChild(renderer.domElement);

        // í™˜ê²½ ë§µ (ë°˜ì‚¬) ì„¤ì •
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { 
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter 
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        scene.add(cubeCamera); 

        // --- 2. ë¹› ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x0C2836, 1.0); 
        directionalLight.position.set(-0.5, 1, 1.8);
        scene.add(directionalLight);

        // --- 3. ì´ë¯¸ì§€ íŒ¨ë„ ìƒì„± ---
        const imageUrls = [];
        const totalImageCount = 30; 
        for (let i = 1; i <= totalImageCount; i++) {
            imageUrls.push(`web-source/${i}.jpg`); 
        }

        const textureLoader = new THREE.TextureLoader();

        const sphereRadius = 8; 
        const numLayers = 5; 
        const imagesPerLayer = Math.ceil(totalImageCount / numLayers); 
        const layerSpacingAngle = Math.PI * 0.10;
        
        const phiLayers = [
            Math.PI * 0.5 - layerSpacingAngle * 2,
            Math.PI * 0.5 - layerSpacingAngle * 1,
            Math.PI * 0.5,
            Math.PI * 0.5 + layerSpacingAngle * 1,
            Math.PI * 0.5 + layerSpacingAngle * 2
        ];
        
        const imageMeshes = [];
        const imageUrlsMap = new Map(); 

        const targetPositions = []; 
        let animationProgress = 0; 
        const animationDuration = 300; 
        
        // ğŸ’¡ 5. ì»¤ì„œ ìƒíƒœ ë³€ìˆ˜ (í•¸ë“¤ë§ ì‹œ ì»¤ì„œ ëª¨ì–‘ ë³€ê²½ì„ ìœ„í•´)
        let isOverClickable = false;

        imageUrls.forEach((url, index) => {
            textureLoader.load(url, (texture) => {
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false; 

                const aspectRatio = texture.image.width / texture.image.height;
                const maxDimension = 2.0; 
                let planeWidth, planeHeight;

                if (aspectRatio >= 1) { 
                    planeWidth = maxDimension;
                    planeHeight = planeWidth / aspectRatio; 
                } else { 
                    planeHeight = maxDimension;
                    planeWidth = planeHeight * aspectRatio; 
                }

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 1 }); 
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.scale.set(0, 0, 0); 
                
                const fileNameMatch = url.match(/(\d+)\.jpg$/);
                let targetPage;

                if (fileNameMatch && fileNameMatch[1]) {
                    const imageNumber = fileNameMatch[1];
                    targetPage = `${imageNumber}.html`;
                } else {
                    targetPage = `page_default.html`; 
                    console.warn(`íŒŒì¼ëª…ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ì–´ ê¸°ë³¸ URLì„ ì‚¬ìš©í•©ë‹ˆë‹¤: ${url}`);
                }

                imageUrlsMap.set(mesh, targetPage); 
                imageMeshes.push(mesh); 

                // ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                const layerIndex = Math.floor(index / imagesPerLayer);
                const phi = phiLayers[layerIndex];
                const indexInLayer = index % imagesPerLayer;
                
                let startOffset = 0;
                if (layerIndex % 2 !== 0) { 
                    startOffset = (Math.PI / imagesPerLayer) / 2;
                }
                
                const angleIncrement = (indexInLayer / imagesPerLayer) * Math.PI;
                const theta_final_corrected = angleIncrement + startOffset + (Math.PI / 1.8); 

                const finalPosition = new THREE.Vector3().setFromSphericalCoords(sphereRadius, phi, theta_final_corrected);
                targetPositions.push(finalPosition); 
                
                // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ì¹´ë©”ë¼ ì• ì¤‘ì•™)
                mesh.position.set(0, 0, -5); 

                mesh.renderOrder = 0; 
                scene.add(mesh);
            });
        });

        // --- 4. ì»¤ìŠ¤í…€ 3D ëª¨ë¸ ë¡œë“œ ---
        const gltfLoader = new GLTFLoader();
        let controller; 
        
        gltfLoader.load(
            'model.glb', 
            (gltf) => {
                const model = gltf.scene;

                model.traverse((child) => {
                    if (child.isMesh) {
                        const originalMaterial = child.material;
                        if (originalMaterial.isMeshStandardMaterial) {
                            originalMaterial.envMap = cubeRenderTarget.texture; 
                            originalMaterial.needsUpdate = true;
                            originalMaterial.depthTest = true; 
                            child.renderOrder = 0; 
                        }
                    }
                });

                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const maxAxis = Math.max(size.x, size.y, size.z);
                const targetScale = 2.2 / maxAxis; 
                const scaleMultiplier = 2; 
                const finalScale = targetScale * scaleMultiplier;

                model.scale.set(finalScale, finalScale, finalScale);
                model.position.x -= center.x * finalScale;
                model.position.y -= center.y * finalScale;
                model.position.z -= center.z * finalScale; 

                const container = new THREE.Object3D();
                container.add(model);
                
                container.position.set(0, 0, -5); 

                controller = container; 
                camera.add(controller);
                console.log("ëª¨ë¸ ë¡œë“œ ì™„ë£Œ"); 
            },
            undefined,
            (error) => {
                console.error('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);
            }
        );
        
        // --- 5. ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  ë° Raycaster ---
        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2();
        let mouseX = 0;
        let mouseY = 0;
        
        // ğŸ’¡ 6. ì»¤ìŠ¤í…€ ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        const updateCustomCursor = (x, y) => {
            customCursor.style.left = `${x}px`;
            customCursor.style.top = `${y}px`;
        };

        function onMouseMove(event) {
            // ğŸ’¡ ì „ì—­ ì»¤ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateCustomCursor(event.clientX, event.clientY);
            
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Raycaster ì—…ë°ì´íŠ¸ (í´ë¦­ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ìœ„ì— ìˆëŠ”ì§€ ì²´í¬)
            mouseVector.x = mouseX;
            mouseVector.y = mouseY;
            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObjects(imageMeshes);
            
            const newIsOverClickable = intersects.length > 0;
            
            if (newIsOverClickable !== isOverClickable) {
                isOverClickable = newIsOverClickable;
                
                // ğŸ’¡ ì»¤ì„œê°€ í´ë¦­ ê°€ëŠ¥í•œ ìš”ì†Œ ìœ„ì— ìˆì„ ë•Œ ëª¨ì–‘ ë³€ê²½
                if (isOverClickable) {
                    customCursor.style.transform = 'translate(-50%, -50%) scale(1.5)';
                } else {
                    customCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                }
            }
        }

        function onMouseClick(event) {
            mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouseVector, camera);

            const intersects = raycaster.intersectObjects(imageMeshes);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const targetUrl = imageUrlsMap.get(intersectedObject);

                if (targetUrl) {
                    console.log(`í˜ì´ì§€ ì´ë™: ${targetUrl}`);
                    window.location.href = targetUrl; 
                }
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        
        // ğŸ’¡ í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬ (í„°ì¹˜ì—ì„œë„ ì»¤ì„œ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸)
        window.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                updateCustomCursor(event.touches[0].clientX, event.touches[0].clientY);
            }
            // Three.js ë¡œì§ì€ mousemoveì™€ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
            onMouseMove({ 
                clientX: event.touches[0].clientX, 
                clientY: event.touches[0].clientY 
            });
        }, { passive: true });


        // --- 6. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ (ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ êµ¬í˜„) ---
        function animate() {
            requestAnimationFrame(animate);

            // ì´ë¯¸ì§€ í¼ì¹¨ ì• ë‹ˆë©”ì´ì…˜ (ìœ„ì¹˜, í¬ê¸°, íˆ¬ëª…ë„)
            if (animationProgress < animationDuration) {
                animationProgress++;
                const ratio = animationProgress / animationDuration; 
                const easedRatio = 1 - Math.pow(1 - ratio, 3); 
                
                imageMeshes.forEach((mesh, index) => {
                    const startPosition = new THREE.Vector3(0, 0, -5); 
                    const targetPosition = targetPositions[index]; 

                    mesh.position.lerpVectors(startPosition, targetPosition, easedRatio);
                    mesh.scale.setScalar(easedRatio);
                    mesh.lookAt(0, 0, 0); 
                });
            }


            // 1. ì¹´ë©”ë¼(ì‹œì„ ) íšŒì „
            const targetCameraRotY = -mouseX * (Math.PI / 4); 
            const targetCameraRotX = mouseY * (Math.PI / 6); 

            yawObject.rotation.y += (targetCameraRotY - yawObject.rotation.y) * 0.05;
            camera.rotation.x += (targetCameraRotX - camera.rotation.x) * 0.05;


            // 2. ë¡œê³ (ëª¨ë¸) íšŒì „
            if (controller) {
                const targetLogoRotY = mouseX * 0.5; 
                const targetLogoRotX = -mouseY * 0.5;

                controller.rotation.y += (targetLogoRotY - controller.rotation.y) * 0.1;
                controller.rotation.x += (targetLogoRotX - controller.rotation.x) * 0.1;

                // 3. í™˜ê²½ ë§µ ì—…ë°ì´íŠ¸ (ë°˜ì‚¬ íš¨ê³¼)
                controller.visible = false;
                
                cubeCamera.position.copy(yawObject.position);
                cubeCamera.rotation.copy(yawObject.rotation); 
                
                cubeCamera.update(renderer, scene); 
                controller.visible = true;
            }

            renderer.render(scene, camera);
        }
        animate();

        // --- 7. ì°½ í¬ê¸° ë³€ê²½ ëŒ€ì‘ ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>